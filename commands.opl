# Opal Development Commands - Clean Slate with Metaprogramming

var PROJECT = "opal"
var VERSION = "$(git describe --tags --always --dirty 2>/dev/null || echo 'dev')"
var MODULES = ["cli", "runtime"]

# =============================================================================
# ğŸ“¦ MODULE COMMANDS - Generated via Metaprogramming
# =============================================================================

for module in @var(MODULES) {
    fun @var(module)_test = @workdir(@var(module)) { 
        @log("ğŸ§ª Testing @var(module) module...")
        go test -v ./... 
    }
    
    fun @var(module)_lint = @workdir(@var(module)) { 
        @log("ğŸ” Linting @var(module) module...")
        command -v golangci-lint >/dev/null 2>&1 && golangci-lint run --timeout=3m || go vet ./...
    }
    
    fun @var(module)_format = @workdir(@var(module)) { 
        @log("ğŸ“ Formatting @var(module) module...")
        command -v gofumpt >/dev/null 2>&1 && gofumpt -w . || go fmt ./...
    }
}

# =============================================================================
# ğŸ”„ GLOBAL COMMANDS
# =============================================================================

fun test {
    @log("ğŸ§ª Testing all modules...")
    for module in @var(MODULES) {
        @cmd(@var(module)_test)
    }
    @log("âœ… All tests passed!")
}

fun format {
    @log("ğŸ“ Formatting all code...")
    @parallel {
        for module in @var(MODULES) {
            @cmd(@var(module)_format)
        }
    }
    @log("âœ… All code formatted!")
}

fun lint {
    @log("ğŸ” Running linters...")
    @parallel {
        for module in @var(MODULES) {
            @cmd(@var(module)_lint)
        }
    }
    @log("âœ… Linting complete!")
}

fun clean {
    @log("ğŸ§¹ Cleaning artifacts...")
    @parallel {
        for module in @var(MODULES) {
            @workdir(@var(module)) { go clean -cache -testcache }
        }
    }
    rm -f @var(PROJECT) coverage.out coverage.html
    @log("âœ… Cleanup complete")
}

fun build {
    @log("ğŸ”¨ Building @var(PROJECT) CLI...")
    @cmd(test)
    @workdir("cli") { go build -ldflags="-s -w -X main.Version=@var(VERSION)" -o ../opal . }
    @log("âœ… Built: ./opal")
}

fun ci {
    @log("ğŸ”„ Clean slate CI workflow...")
    @cmd(format)
    @cmd(lint) 
    @cmd(test)
    @log("âœ… CI complete!")
}

fun info = @log("ğŸ“Š @var(PROJECT) Clean Slate Status
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
Project: @var(PROJECT) (Plan-Verify-Execute Engine)
Version: @var(VERSION)

Current Modules: @var(MODULES)
  cli/        - Command-line interface
  runtime/    - Lexer v2 (high-performance tokenization)
  docs/       - Architecture and specification

Ready for fresh AST and parser implementation!")

fun help = @log("ğŸ”§ Opal Development Commands (Clean Slate)

ğŸš€ Main Commands:
  build     - Build CLI binary
  ci        - Full CI workflow (format, lint, test)
  test      - Run all tests
  clean     - Clean artifacts

ğŸ“ Code Quality:
  format    - Format all code
  lint      - Run linters

ğŸ“Š Utilities:
  info      - Show project status
  help      - Show this help

ğŸ’¡ Module-specific commands are auto-generated:
  cli_test, cli_lint, cli_format
  runtime_test, runtime_lint, runtime_format")